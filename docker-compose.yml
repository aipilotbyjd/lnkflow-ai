# LinkFlow - Base Service Definitions
# All services with production-ready defaults
#
# Usage:
#   Development: docker compose up -d              (auto-loads override.yml)
#   Production:  docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d
#   CI/Testing:  docker compose -f docker-compose.yml -f docker-compose.test.yml up -d

x-common-env: &common-env
  DATABASE_URL: postgres://${POSTGRES_USER:-linkflow}:${POSTGRES_PASSWORD:?Set POSTGRES_PASSWORD in .env}@postgres:5432/${POSTGRES_DB:-linkflow}?sslmode=disable&search_path=workflow
  REDIS_URL: redis://:${REDIS_PASSWORD:?Set REDIS_PASSWORD in .env}@redis:6379
  LOG_LEVEL: ${LOG_LEVEL:-info}
  LOG_FORMAT: json

x-common-config: &common-config
  restart: unless-stopped
  networks:
    - linkflow
  logging:
    driver: json-file
    options:
      max-size: "10m"
      max-file: "3"

x-api-env: &api-env
  DB_CONNECTION: pgsql
  DB_HOST: postgres
  DB_PORT: "5432"
  DB_DATABASE: ${POSTGRES_DB:-linkflow}
  DB_USERNAME: ${POSTGRES_USER:-linkflow}
  DB_PASSWORD: ${POSTGRES_PASSWORD}
  REDIS_HOST: redis
  REDIS_PASSWORD: ${REDIS_PASSWORD}
  APP_KEY: ${APP_KEY:-}
  LINKFLOW_ENGINE_SECRET: ${LINKFLOW_SECRET}
  ENGINE_PARTITION_COUNT: ${ENGINE_PARTITION_COUNT:-16}
  REDIS_QUEUE: workflows-default

x-api-build: &api-build
  context: ./apps/api
  dockerfile: Dockerfile
  target: production

x-engine-build: &engine-build
  context: ./apps/engine
  dockerfile: Dockerfile

services:
  # ============================================
  # Infrastructure
  # ============================================
  postgres:
    image: postgres:16-alpine
    <<: *common-config
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-linkflow}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:?Set POSTGRES_PASSWORD in .env}
      POSTGRES_DB: ${POSTGRES_DB:-linkflow}
      POSTGRES_INITDB_ARGS: "--encoding=UTF8 --locale=C"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./infra/init:/docker-entrypoint-initdb.d:ro
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-linkflow} -d ${POSTGRES_DB:-linkflow}"]
      interval: 5s
      timeout: 5s
      retries: 5
      start_period: 10s
    command: >
      postgres
        -c shared_buffers=256MB
        -c max_connections=200
        -c work_mem=16MB
        -c maintenance_work_mem=128MB
        -c effective_cache_size=512MB
        -c log_min_duration_statement=1000
    read_only: true
    tmpfs:
      - /tmp
      - /run/postgresql

  redis:
    image: redis:7-alpine
    <<: *common-config
    volumes:
      - redis_data:/data
    command: >
      redis-server
        --appendonly yes
        --appendfsync everysec
        --maxmemory 256mb
        --maxmemory-policy noeviction
        --requirepass ${REDIS_PASSWORD:?Set REDIS_PASSWORD in .env}
    healthcheck:
      test: ["CMD-SHELL", "REDISCLI_AUTH=$REDIS_PASSWORD redis-cli ping"]
      interval: 5s
      timeout: 5s
      retries: 5
    read_only: true
    tmpfs:
      - /tmp

  # ============================================
  # Laravel API
  # ============================================
  api:
    build:
      <<: *api-build
    <<: *common-config
    env_file:
      - ./apps/api/.env.docker
    environment:
      <<: *api-env
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/api/v1/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy

  queue:
    build:
      <<: *api-build
    <<: *common-config
    env_file:
      - ./apps/api/.env.docker
    environment:
      <<: *api-env
    command: php artisan queue:work redis --queue=workflows-high,workflows-default,workflows-low,default --sleep=3 --tries=3 --max-time=3600 --max-jobs=1000 --verbose
    healthcheck:
      test: ["CMD-SHELL", "ps aux | grep -v grep | grep 'queue:work' || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    depends_on:
      api:
        condition: service_healthy

  scheduler:
    build:
      <<: *api-build
    <<: *common-config
    env_file:
      - ./apps/api/.env.docker
    environment:
      <<: *api-env
    command: >
      sh -c "while true; do php artisan schedule:run --verbose; sleep 60; done"
    healthcheck:
      test: ["CMD-SHELL", "pgrep -f 'schedule:run|sleep' || exit 1"]
      interval: 60s
      timeout: 10s
      retries: 3
      start_period: 10s
    depends_on:
      api:
        condition: service_healthy
    profiles:
      - scheduler

  # ============================================
  # Go Engine - Core Services
  # ============================================
  frontend:
    build:
      <<: *engine-build
      args:
        SERVICE: frontend
    <<: *common-config
    environment:
      <<: *common-env
      SERVICE_NAME: frontend
      HTTP_PORT: "8080"
      GRPC_PORT: "9090"
      HISTORY_ADDR: history:7234
      MATCHING_ADDR: matching:7235
      VISIBILITY_ADDR: visibility:7237
      JWT_SECRET: ${JWT_SECRET:?Set JWT_SECRET in .env}
      RATE_LIMIT_REQUESTS: "1000"
      RATE_LIMIT_WINDOW: 60s
      ENGINE_PARTITION_COUNT: ${ENGINE_PARTITION_COUNT:-16}
      JOB_CONSUMER_GROUP: engine-group
      JOB_CLAIM_MIN_IDLE: 30s
      JOB_CLAIM_BATCH: "50"
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:8080/health"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    depends_on:
      history:
        condition: service_healthy
      matching:
        condition: service_healthy

  history:
    build:
      <<: *engine-build
      args:
        SERVICE: history
    <<: *common-config
    environment:
      <<: *common-env
      SERVICE_NAME: history
      GRPC_PORT: "7234"
      HTTP_PORT: "8080"
      SHARD_COUNT: "16"
      MATCHING_ADDR: matching:7235
      TIMER_ADDR: timer:7238
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:8080/health"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy

  matching:
    build:
      <<: *engine-build
      args:
        SERVICE: matching
    <<: *common-config
    environment:
      <<: *common-env
      SERVICE_NAME: matching
      GRPC_PORT: "7235"
      HTTP_PORT: "8080"
      PARTITION_COUNT: "4"
      TASK_QUEUE_SYNC_INTERVAL: 1s
      LONG_POLL_TIMEOUT: 60s
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:8080/health"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy

  worker:
    build:
      <<: *engine-build
      args:
        SERVICE: worker
    <<: *common-config
    environment:
      <<: *common-env
      SERVICE_NAME: worker
      HTTP_PORT: "8080"
      MATCHING_ADDR: matching:7235
      HISTORY_ADDR: history:7234
      TASK_QUEUE: workflows-high,workflows-default,workflows-low,default
      NUM_WORKERS: "4"
      POLL_INTERVAL: 1s
      CALLBACK_URL: http://api:8000/api/v1/jobs/callback
      CALLBACK_SECRET: ${LINKFLOW_SECRET:?Set LINKFLOW_SECRET in .env}
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:8080/health"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    depends_on:
      matching:
        condition: service_healthy

  timer:
    build:
      <<: *engine-build
      args:
        SERVICE: timer
    <<: *common-config
    environment:
      <<: *common-env
      SERVICE_NAME: timer
      GRPC_PORT: "7238"
      HTTP_PORT: "8080"
      HISTORY_ADDR: history:7234
      SCAN_INTERVAL: 1s
      BATCH_SIZE: "100"
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:8080/health"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    depends_on:
      history:
        condition: service_healthy

  visibility:
    build:
      <<: *engine-build
      args:
        SERVICE: visibility
    <<: *common-config
    environment:
      <<: *common-env
      SERVICE_NAME: visibility
      GRPC_PORT: "7237"
      HTTP_PORT: "8080"
      ELASTICSEARCH_URL: ${ELASTICSEARCH_URL:-}
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:8080/health"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy

  # ============================================
  # Go Engine - Optional Services
  # ============================================
  edge:
    build:
      <<: *engine-build
      args:
        SERVICE: edge
    <<: *common-config
    environment:
      <<: *common-env
      SERVICE_NAME: edge
      HTTP_PORT: "8080"
      FRONTEND_ADDR: frontend:9090
      SYNC_INTERVAL: 30s
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:8080/health"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    profiles:
      - edge

  control-plane:
    build:
      <<: *engine-build
      args:
        SERVICE: control-plane
    <<: *common-config
    environment:
      <<: *common-env
      SERVICE_NAME: control-plane
      GRPC_PORT: "7239"
      HTTP_PORT: "8080"
      CELL_ID: ${CELL_ID:-cell-1}
      REGION: ${REGION:-local}
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:8080/health"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    profiles:
      - control

  # ============================================
  # Migrations (one-time)
  # ============================================
  migrate:
    build:
      <<: *engine-build
      args:
        SERVICE: worker
    environment:
      DATABASE_URL: postgres://${POSTGRES_USER:-linkflow}:${POSTGRES_PASSWORD:?Set POSTGRES_PASSWORD in .env}@postgres:5432/${POSTGRES_DB:-linkflow}?sslmode=disable&search_path=workflow
    command: >
      sh -c "
        echo 'ðŸ”„ Running Go Engine migrations...' &&
        /app/service --migrate-only || echo 'Migration command not supported' &&
        echo 'âœ… Go Engine migrations complete!'
      "
    networks:
      - linkflow
    profiles:
      - migrate

  # ============================================
  # Nginx (production only â€” added via docker-compose.prod.yml)
  # ============================================
  nginx:
    image: nginx:1.25-alpine
    <<: *common-config
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost/health"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 5s
    read_only: true
    tmpfs:
      - /tmp
      - /var/run
    profiles:
      - production

volumes:
  postgres_data:
    name: linkflow_postgres_data
  redis_data:
    name: linkflow_redis_data
  nginx_logs:
    name: linkflow_nginx_logs

networks:
  linkflow:
    name: linkflow
    driver: bridge
